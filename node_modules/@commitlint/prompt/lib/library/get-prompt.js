"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const format_1 = __importDefault(require("./format"));
const get_forced_case_fn_1 = __importDefault(require("./get-forced-case-fn"));
const get_forced_leading_fn_1 = __importDefault(require("./get-forced-leading-fn"));
const meta_1 = __importDefault(require("./meta"));
const utils_1 = require("./utils");
/**
 * Get a cli prompt based on rule configuration
 * @param type type of the data to gather
 * @param context rules to parse
 * @return prompt instance
 */
function getPrompt(type, context = {}) {
    const { rules = [], settings = {}, results = {}, prompter } = context;
    if (typeof prompter !== 'function') {
        throw new TypeError('Missing prompter function in getPrompt context');
    }
    const prompt = prompter();
    if (typeof prompt.removeAllListeners !== 'function') {
        throw new TypeError('getPrompt: prompt.removeAllListeners is not a function');
    }
    if (typeof prompt.command !== 'function') {
        throw new TypeError('getPrompt: prompt.command is not a function');
    }
    if (typeof prompt.catch !== 'function') {
        throw new TypeError('getPrompt: prompt.catch is not a function');
    }
    if (typeof prompt.addListener !== 'function') {
        throw new TypeError('getPrompt: prompt.addListener is not a function');
    }
    if (typeof prompt.log !== 'function') {
        throw new TypeError('getPrompt: prompt.log is not a function');
    }
    if (typeof prompt.delimiter !== 'function') {
        throw new TypeError('getPrompt: prompt.delimiter is not a function');
    }
    if (typeof prompt.show !== 'function') {
        throw new TypeError('getPrompt: prompt.show is not a function');
    }
    const enumRule = rules.filter(utils_1.getHasName('enum')).find(utils_1.enumRuleIsActive);
    const emptyRule = rules.find(utils_1.getHasName('empty'));
    const mustBeEmpty = emptyRule && utils_1.ruleIsActive(emptyRule) && utils_1.ruleIsApplicable(emptyRule);
    const mayNotBeEmpty = emptyRule && utils_1.ruleIsActive(emptyRule) && utils_1.ruleIsNotApplicable(emptyRule);
    const mayBeEmpty = !mayNotBeEmpty;
    if (mustBeEmpty) {
        prompt.removeAllListeners('keypress');
        prompt.removeAllListeners('client_prompt_submit');
        prompt.ui.redraw.done();
        return Promise.resolve(undefined);
    }
    const caseRule = rules.find(utils_1.getHasName('case'));
    const forceCaseFn = get_forced_case_fn_1.default(caseRule);
    const leadingBlankRule = rules.find(utils_1.getHasName('leading-blank'));
    const forceLeadingBlankFn = get_forced_leading_fn_1.default(leadingBlankRule);
    const maxLengthRule = rules.find(utils_1.getHasName('max-length'));
    const inputMaxLength = utils_1.getMaxLength(maxLengthRule);
    const headerLength = settings.header ? settings.header.length : Infinity;
    const remainingHeaderLength = headerLength
        ? headerLength -
            [
                results.type,
                results.scope,
                results.scope ? '()' : '',
                results.type && results.scope ? ':' : '',
                results.subject,
            ].join('').length
        : Infinity;
    const maxLength = Math.min(inputMaxLength, remainingHeaderLength);
    return new Promise((resolve) => {
        // Add the defined enums as sub commands if applicable
        if (enumRule) {
            const [, [, , enums]] = enumRule;
            enums.forEach((enumerable) => {
                const enumSettings = (settings.enumerables || {})[enumerable] || {};
                prompt
                    .command(enumerable)
                    .description(enumSettings.description || '')
                    .action(() => {
                    prompt.removeAllListeners();
                    prompt.ui.redraw.done();
                    return resolve(forceLeadingBlankFn(forceCaseFn(enumerable)));
                });
            });
        }
        else {
            prompt.catch('[text...]').action((parameters) => {
                const { text = '' } = parameters;
                prompt.removeAllListeners();
                prompt.ui.redraw.done();
                return resolve(forceLeadingBlankFn(forceCaseFn(text.join(' '))));
            });
        }
        if (mayBeEmpty) {
            // Add an easy exit command
            prompt
                .command(':skip')
                .description('Skip the input if possible.')
                .action(() => {
                prompt.removeAllListeners();
                prompt.ui.redraw.done();
                resolve('');
            });
        }
        // Handle empty input
        const onSubmit = (input) => {
            if (input.length > 0) {
                return;
            }
            // Show help if enum is defined and input may not be empty
            if (mayNotBeEmpty) {
                prompt.ui.log(chalk_1.default.yellow(`⚠ ${chalk_1.default.bold(type)} may not be empty.`));
            }
            if (mayBeEmpty) {
                prompt.ui.log(chalk_1.default.blue(`ℹ Enter ${chalk_1.default.bold(':skip')} to omit ${chalk_1.default.bold(type)}.`));
            }
            if (enumRule) {
                prompt.exec('help');
            }
        };
        const drawRemaining = (length) => {
            if (length < Infinity) {
                const colors = [
                    {
                        threshold: 5,
                        color: chalk_1.default.red,
                    },
                    {
                        threshold: 10,
                        color: chalk_1.default.yellow,
                    },
                    {
                        threshold: Infinity,
                        color: chalk_1.default.grey,
                    },
                ];
                const el = colors.find((item) => item.threshold >= length);
                const color = el ? el.color : chalk_1.default.grey;
                prompt.ui.redraw(color(`${length} characters left`));
            }
        };
        const onKey = (event) => {
            const sanitized = forceCaseFn(event.value);
            const cropped = sanitized.slice(0, maxLength);
            // We **could** do live editing, but there are some quirks to solve
            /* const live = merge({}, results, {
                [type]: cropped
            });
            prompt.ui.redraw(`\n\n${format(live, true)}\n\n`); */
            if (maxLength) {
                drawRemaining(maxLength - cropped.length);
            }
            prompt.ui.input(cropped);
        };
        prompt.addListener('keypress', onKey);
        prompt.addListener('client_prompt_submit', onSubmit);
        prompt.log(`\n\nPlease enter a ${chalk_1.default.bold(type)}: ${meta_1.default({
            optional: !mayNotBeEmpty,
            required: mayNotBeEmpty,
            'tab-completion': typeof enumRule !== 'undefined',
            header: typeof settings.header !== 'undefined',
            'multi-line': settings.multiline,
        })}`);
        if (settings.description) {
            prompt.log(chalk_1.default.grey(`${settings.description}\n`));
        }
        prompt.log(`\n\n${format_1.default(results, true)}\n\n`);
        drawRemaining(maxLength);
        prompt.delimiter(`❯ ${type}:`).show();
    });
}
exports.default = getPrompt;
//# sourceMappingURL=get-prompt.js.map